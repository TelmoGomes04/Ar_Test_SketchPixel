<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>AR Test</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.rawgit.com/mrdoob/three.js/r128/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        body {
            overflow: hidden;
            margin: 0;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            display: none;
        }
        #renderCanvas {
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
    <div id="info">Tap to place object</div>
    <script>

        let renderer, scene, camera;
        let cube, plane;
        let xrSession = null;

        init();

        async function init() {
            const container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 10);
            camera.position.set(0, 1.6, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            // Add lighting
            const light = new THREE.HemisphereLight(0xffffff, 0x444444);
            light.position.set(0, 1, 0);
            scene.add(light);

            // Create a loader for GLTF models
            const loader = new THREE.GLTFLoader();
            loader.load('media/gltf/F3_Car/scene.gltf', (gltf) => {
                const model = gltf.scene;
                model.scale.set(0.3, 0.3, 0.3);
                model.visible = false;
                scene.add(model);
                cube = model;
            });

            // Create a plane to use for hit testing
            const geometry = new THREE.PlaneGeometry(4, 4, 1, 1);
            const material = new THREE.MeshBasicMaterial({ visible: false });
            plane = new THREE.Mesh(geometry, material);
            plane.rotation.x = -Math.PI / 2;
            scene.add(plane);

            // Handle XR session creation and hit testing
            const button = document.createElement('button');
            button.textContent = 'Enter AR';
            document.body.appendChild(button);

            button.addEventListener('click', async () => {
                if (!xrSession) {
                    xrSession = await navigator.xr.requestSession('immersive-ar', {
                        requiredFeatures: ['hit-test']
                    });
                    xrSession.addEventListener('end', onSessionEnd);

                    renderer.xr.setReferenceSpaceType('local');
                    renderer.xr.setSession(xrSession);

                    button.style.display = 'none';
                    document.getElementById('info').style.display = 'block';

                    xrSession.addEventListener('select', onSelect);

                    const hitTestSource = await xrSession.requestHitTestSource({ space: xrSession.worldSpace });
                    xrSession.addEventListener('end', onSessionEnd);

                    let hitTestResults = [];
                    const ray = new THREE.Ray();

                    function onSelect(event) {
                        if (hitTestResults.length > 0) {
                            const hit = hitTestResults[0];
                            const position = hit.getPose(xrSession.referenceSpace).transform.position;
                            cube.position.copy(position);
                            cube.visible = true;
                        }
                    }

                    function onSessionEnd() {
                        cube.visible = false;
                        xrSession = null;
                        button.style.display = 'block';
                        document.getElementById('info').style.display = 'none';
                    }

                    function animate() {
                        renderer.setAnimationLoop(() => {
                            xrSession.requestAnimationFrame(animate);

                            // Get hit test results
                            const hitTestResults = xrSession.requestHitTest(hitTestSource);
                            if (hitTestResults.length > 0) {
                                const pose = hitTestResults[0].getPose(xrSession.localSpace);
                                if (pose) {
                                    plane.position.copy(pose.transform.position);
                                    plane.quaternion.copy(pose.transform.orientation);
                                }
                            }

                            renderer.render(scene, camera);
                        });
                    }

                    animate();
                }
            });

            window.addEventListener('resize', onWindowResize, false);

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

    </script>
</body>
</html>
